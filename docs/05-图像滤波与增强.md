# 图像滤波与增强

## 学习目标

- 理解图像滤波的概念和原理
- 掌握常见的平滑滤波方法（均值、高斯、中值）
- 学会图像锐化技术
- 掌握边缘检测方法（Sobel、Canny）

---

## 一、图像滤波简介

### 1.1 什么是滤波？

**滤波（Filtering）**是通过卷积核对图像进行操作，用于：
- **去噪**：去除图像噪声
- **平滑**：减少图像细节
- **锐化**：增强边缘
- **特征提取**：提取特定特征

### 1.2 卷积核（Kernel）

**卷积核**是一个小矩阵（如3x3、5x5），在图像上滑动进行运算。

**示例：3x3均值滤波核**
```
1/9  1/9  1/9
1/9  1/9  1/9
1/9  1/9  1/9
```

---

## 二、图像平滑（去噪）

### 2.1 均值滤波

**原理：** 用邻域像素的平均值替换中心像素

**语法：**
```python
blur = cv2.blur(src, ksize)
```

**参数：**
- `ksize`：核大小，如 (5, 5)

**示例：**
```python
import cv2

img = cv2.imread('noisy.jpg')

# 均值滤波（5x5核）
blur = cv2.blur(img, (5, 5))

# 更大的核（更平滑）
blur_large = cv2.blur(img, (15, 15))

cv2.imshow('Original', img)
cv2.imshow('Blurred 5x5', blur)
cv2.imshow('Blurred 15x15', blur_large)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**特点：**
- 简单快速
- 模糊边缘
- 对椒盐噪声效果一般

### 2.2 高斯滤波

**原理：** 使用高斯分布加权，中心像素权重更大

**语法：**
```python
blur = cv2.GaussianBlur(src, ksize, sigmaX)
```

**参数：**
- `ksize`：核大小，必须是正奇数，如 (5, 5)
- `sigmaX`：X方向标准差，0表示自动计算

**示例：**
```python
import cv2

img = cv2.imread('noisy.jpg')

# 高斯滤波（5x5核）
gaussian = cv2.GaussianBlur(img, (5, 5), 0)

# 更强的高斯滤波
gaussian_strong = cv2.GaussianBlur(img, (9, 9), 0)

cv2.imshow('Original', img)
cv2.imshow('Gaussian 5x5', gaussian)
cv2.imshow('Gaussian 9x9', gaussian_strong)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**特点：**
- 比均值滤波效果好
- 保留边缘更好
- 对高斯噪声效果好

### 2.3 中值滤波

**原理：** 用邻域像素的中值替换中心像素

**语法：**
```python
blur = cv2.medianBlur(src, ksize)
```

**参数：**
- `ksize`：核大小，必须是正奇数，如 5

**示例：**
```python
import cv2

img = cv2.imread('salt-pepper-noise.jpg')

# 中值滤波（5x5核）
median = cv2.medianBlur(img, 5)

# 更强的中值滤波
median_strong = cv2.medianBlur(img, 9)

cv2.imshow('Original', img)
cv2.imshow('Median 5', median)
cv2.imshow('Median 9', median_strong)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**特点：**
- 对椒盐噪声效果最好
- 保留边缘
- 速度较慢

### 2.4 双边滤波

**原理：** 在平滑的同时保留边缘

**语法：**
```python
blur = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)
```

**参数：**
- `d`：像素邻域直径
- `sigmaColor`：颜色空间的标准差
- `sigmaSpace`：坐标空间的标准差

**示例：**
```python
import cv2

img = cv2.imread('face.jpg')

# 双边滤波（美颜效果）
bilateral = cv2.bilateralFilter(img, 15, 80, 80)

cv2.imshow('Original', img)
cv2.imshow('Bilateral Filter', bilateral)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**特点：**
- 保留边缘
- 计算慢
- 适合美颜、磨皮

---

## 三、图像锐化

### 3.1 锐化核

**示例：锐化卷积核**
```python
import cv2
import numpy as np

img = cv2.imread('blur.jpg')

# 定义锐化核
kernel_sharpen = np.array([
    [-1, -1, -1],
    [-1,  9, -1],
    [-1, -1, -1]
])

# 应用卷积
sharpened = cv2.filter2D(img, -1, kernel_sharpen)

cv2.imshow('Original', img)
cv2.imshow('Sharpened', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 3.2 拉普拉斯锐化

```python
import cv2
import numpy as np

img = cv2.imread('blur.jpg')

# 拉普拉斯算子
laplacian = cv2.Laplacian(img, cv2.CV_64F)

# 转换回uint8
laplacian = np.uint8(np.absolute(laplacian))

# 锐化结果
sharpened = cv2.add(img, laplacian)

cv2.imshow('Original', img)
cv2.imshow('Sharpened', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 四、边缘检测

### 4.1 Sobel算子

**原理：** 计算图像梯度，检测边缘

**语法：**
```python
sobelx = cv2.Sobel(src, ddepth, dx, dy, ksize)
sobely = cv2.Sobel(src, ddepth, dx, dy, ksize)
```

**参数：**
- `ddepth`：输出图像深度，`cv2.CV_64F`可检测负梯度
- `dx, dy`：x和y方向的导数阶数（0或1）
- `ksize`：核大小，1, 3, 5, 7

**示例：**
```python
import cv2
import numpy as np

img = cv2.imread('edges.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# X方向梯度（检测垂直边缘）
sobelx = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)
sobelx = np.uint8(np.absolute(sobelx))

# Y方向梯度（检测水平边缘）
sobely = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)
sobely = np.uint8(np.absolute(sobely))

# 组合梯度
sobel_combined = cv2.addWeighted(sobelx, 0.5, sobely, 0.5, 0)

cv2.imshow('Original', gray)
cv2.imshow('Sobel X', sobelx)
cv2.imshow('Sobel Y', sobely)
cv2.imshow('Sobel Combined', sobel_combined)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 4.2 Canny边缘检测

**原理：** 多阶段边缘检测算法，效果最好

**语法：**
```python
edges = cv2.Canny(src, threshold1, threshold2, apertureSize, L2gradient)
```

**参数：**
- `threshold1`：低阈值（弱边缘）
- `threshold2`：高阈值（强边缘）
- `apertureSize`：Sobel算子核大小，默认3
- `L2gradient`：是否使用更精确的梯度计算

**示例：**
```python
import cv2

img = cv2.imread('edges.jpg')
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Canny边缘检测
edges = cv2.Canny(gray, 100, 200)

# 调整阈值
edges_low = cv2.Canny(gray, 50, 150)
edges_high = cv2.Canny(gray, 150, 250)

cv2.imshow('Original', gray)
cv2.imshow('Canny 100-200', edges)
cv2.imshow('Canny 50-150', edges_low)
cv2.imshow('Canny 150-250', edges_high)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**阈值选择建议：**
- `threshold2`通常是`threshold1`的2-3倍
- 推荐值：50-150、100-200、150-300

---

## 五、综合应用

### 示例1：对比四种滤波方法

```python
import cv2

img = cv2.imread('noisy.jpg')

# 均值滤波
blur = cv2.blur(img, (5, 5))

# 高斯滤波
gaussian = cv2.GaussianBlur(img, (5, 5), 0)

# 中值滤波
median = cv2.medianBlur(img, 5)

# 双边滤波
bilateral = cv2.bilateralFilter(img, 9, 75, 75)

cv2.imshow('Original', img)
cv2.imshow('Mean', blur)
cv2.imshow('Gaussian', gaussian)
cv2.imshow('Median', median)
cv2.imshow('Bilateral', bilateral)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 示例2：边缘检测流程

```python
import cv2

img = cv2.imread('photo.jpg')

# 1. 转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2. 高斯滤波（降噪）
blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# 3. Canny边缘检测
edges = cv2.Canny(blurred, 50, 150)

# 4. 膨胀边缘（连接断开的边缘）
kernel = np.ones((3, 3), np.uint8)
edges_dilated = cv2.dilate(edges, kernel, iterations=1)

cv2.imshow('Original', img)
cv2.imshow('Edges', edges)
cv2.imshow('Edges Dilated', edges_dilated)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 示例3：简单美颜滤镜

```python
import cv2

img = cv2.imread('face.jpg')

# 1. 双边滤波（磨皮）
smooth = cv2.bilateralFilter(img, 15, 80, 80)

# 2. 混合原图（保留细节）
result = cv2.addWeighted(img, 0.3, smooth, 0.7, 0)

# 3. 可选：美白
# result = cv2.convertScaleAbs(result, alpha=1.2, beta=20)

cv2.imshow('Original', img)
cv2.imshow('Beauty Filter', result)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 六、常见问题

### Q1：如何选择滤波方法？

| 滤波方法 | 适用场景 | 特点 |
|---------|---------|------|
| 均值滤波 | 快速去噪 | 简单但模糊边缘 |
| 高斯滤波 | 高斯噪声 | 保留边缘较好 |
| 中值滤波 | 椒盐噪声 | 最好效果，保留细节 |
| 双边滤波 | 美颜磨皮 | 保留边缘，计算慢 |

### Q2：Canny阈值如何选择？

```python
# 自动计算阈值（Otsu方法）
median = np.median(gray)
lower = int(max(0, 0.7 * median))
upper = int(min(255, 1.3 * median))
edges = cv2.Canny(gray, lower, upper)
```

### Q3：为什么边缘检测结果不理想？

**可能原因：**
1. 图像噪声太多 → 先滤波
2. 阈值设置不当 → 调整阈值
3. 光照不均 → 预处理

---

## 七、练习题

### 练习1：滤波对比（⭐⭐）
对同一张含噪图片分别使用均值、高斯、中值滤波，对比效果并说明优劣。

### 练习2：Canny参数调试（⭐⭐）
使用滑动条交互调整Canny边缘检测的阈值，找到最佳参数。

### 练习3：素描效果（⭐⭐⭐）
结合边缘检测和灰度图，创建素描风格效果。

### 练习4：卡通效果（⭐⭐⭐）
结合双边滤波和边缘检测，创建卡通效果。

### 练习5：实时边缘检测（⭐⭐⭐⭐）
从摄像头读取视频，实时显示Canny边缘检测结果。

---

## 八、扩展思考

1. **为什么中值滤波对椒盐噪声效果好？**
   - 提示：中值不受极值影响

2. **双边滤波为什么能保留边缘？**
   - 提示：同时考虑空间和颜色差异

3. **Canny为什么是最佳边缘检测算法？**
   - 提示：多阶段算法，非极大值抑制

---

**下一步：** 学习[06-图像阈值处理](./06-图像阈值处理.md)
