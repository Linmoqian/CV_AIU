# 图像阈值处理

## 学习目标

- 理解图像阈值分割的原理
- 掌握简单的阈值处理方法
- 学会自适应阈值处理
- 理解Otsu二值化算法

---

## 一、阈值分割简介

### 1.1 什么是阈值分割？

**阈值分割（Thresholding）**是将灰度图像转换为二值图像的方法：
- 像素值 > 阈值 → 设为255（白色）
- 像素值 ≤ 阈值 → 设为0（黑色）

### 1.2 应用场景

- 文档扫描（文字提取）
- 车牌识别
- 物体分割
- 图像二值化预处理

---

## 二、简单阈值

### 2.1 语法

```python
retval, dst = cv2.threshold(src, thresh, maxval, type)
```

**参数：**
- `src`：输入图像（必须是灰度图）
- `thresh`：阈值
- `maxval`：最大值（通常255）
- `type`：阈值类型

**阈值类型：**
- `cv2.THRESH_BINARY`：二值化
- `cv2.THRESH_BINARY_INV`：反二值化
- `cv2.THRESH_TRUNC`：截断
- `cv2.THRESH_TOZERO`：低于阈值置0
- `cv2.THRESH_TOZERO_INV`：高于阈值置0

### 2.2 示例

```python
import cv2

img = cv2.imread('document.jpg', cv2.IMREAD_GRAYSCALE)

# 固定阈值二值化
ret, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

# 反二值化
ret, thresh2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV)

# 截断（大于阈值的设为阈值）
ret, thresh3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC)

# 低于阈值置0
ret, thresh4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO)

# 高于阈值置0
ret, thresh5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV)

cv2.imshow('Original', img)
cv2.imshow('BINARY', thresh1)
cv2.imshow('BINARY_INV', thresh2)
cv2.imshow('TRUNC', thresh3)
cv2.imshow('TOZERO', thresh4)
cv2.imshow('TOZERO_INV', thresh5)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 三、Otsu二值化

### 3.1 原理

**Otsu方法**自动计算最佳阈值，使前景和背景的类间方差最大。

**优点：**
- 不需要手动设置阈值
- 适合双峰直方图图像

### 3.2 示例

```python
import cv2

img = cv2.imread('document.jpg', cv2.IMREAD_GRAYSCALE)

# 全局阈值（手动设置127）
ret1, thresh1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

# Otsu阈值（自动计算）
ret2, thresh2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

print(f"Otsu计算的阈值: {ret2}")

cv2.imshow('Original', img)
cv2.imshow('Manual Threshold', thresh1)
cv2.imshow('Otsu Threshold', thresh2)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**⚠️ 注意：** 使用Otsu时，阈值参数设为0，并添加`cv2.THRESH_OTSU`标志。

---

## 四、自适应阈值

### 4.1 原理

**自适应阈值**根据像素邻域动态计算阈值，适合光照不均的图像。

**两种方法：**
- `cv2.ADAPTIVE_THRESH_MEAN_C`：邻域均值
- `cv2.ADAPTIVE_THRESH_GAUSSIAN_C`：邻域高斯加权

### 4.2 语法

```python
dst = cv2.adaptiveThreshold(src, maxValue, adaptiveMethod,
                            thresholdType, blockSize, C)
```

**参数：**
- `maxValue`：最大值（通常255）
- `adaptiveMethod`：自适应方法
- `thresholdType`：阈值类型（BINARY或BINARY_INV）
- `blockSize`：邻域大小，必须是奇数，如3, 5, 7...
- `C`：从均值或加权均值减去的常数

### 4.3 示例

```python
import cv2

img = cv2.imread('uneven-lighting.jpg', cv2.IMREAD_GRAYSCALE)

# 简单阈值
ret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)

# Otsu阈值
ret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# 自适应阈值（均值）
th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                            cv2.THRESH_BINARY, 11, 2)

# 自适应阈值（高斯）
th4 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv2.THRESH_BINARY, 11, 2)

cv2.imshow('Original', img)
cv2.imshow('Global Threshold', th1)
cv2.imshow('Otsu Threshold', th2)
cv2.imshow('Adaptive Mean', th3)
cv2.imshow('Adaptive Gaussian', th4)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 五、阈值选择指南

### 5.1 什么时候用哪种方法？

| 方法 | 适用场景 | 特点 |
|-----|---------|------|
| **全局阈值** | 光照均匀 | 简单快速 |
| **Otsu** | 双峰直方图 | 自动找阈值 |
| **自适应阈值** | 光照不均 | 效果最好 |
| **自适应均值** | 光照不均 | 计算快 |
| **自适应高斯** | 光照不均 | 效果好但慢 |

### 5.2 参数调优

**自适应阈值参数：**
- `blockSize`：邻域大小
  - 较小值（3-11）：细节多，噪声多
  - 较大值（15-31）：平滑，丢失细节
- `C`：减去的常数
  - 较大值（10-30）：更多噪声被过滤
  - 较小值（1-5）：保留更多细节

**示例调优：**
```python
# 尝试不同参数组合
th1 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv2.THRESH_BINARY, 11, 2)  # 默认
th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv2.THRESH_BINARY, 15, 5)  # 更平滑
th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv2.THRESH_BINARY, 7, 1)   # 更细节
```

---

## 六、综合应用

### 示例1：文档扫描预处理

```python
import cv2

img = cv2.imread('document.jpg')

# 1. 转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2. 高斯滤波（降噪）
blurred = cv2.GaussianBlur(gray, (5, 5), 0)

# 3. 自适应阈值
thresh = cv2.adaptiveThreshold(blurred, 255,
                               cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY, 11, 2)

# 4. 形态学操作（去除小噪声）
kernel = np.ones((2, 2), np.uint8)
cleaned = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)

cv2.imshow('Original', img)
cv2.imshow('Thresholded', thresh)
cv2.imshow('Cleaned', cleaned)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 示例2：车牌定位预处理

```python
import cv2

img = cv2.imread('car.jpg')

# 1. 转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2. 高斯滤波
blur = cv2.GaussianBlur(gray, (5, 5), 0)

# 3. Sobel边缘检测（垂直边缘）
sobelx = cv2.Sobel(blur, cv2.CV_64F, 1, 0, ksize=3)
sobelx = np.uint8(np.absolute(sobelx))

# 4. Otsu阈值
ret, thresh = cv2.threshold(sobelx, 0, 255,
                           cv2.THRESH_BINARY + cv2.THRESH_OTSU)

cv2.imshow('Original', img)
cv2.imshow('Sobel', sobelx)
cv2.imshow('Threshold', thresh)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 示例3：交互式阈值调试

```python
import cv2

def nothing(x):
    pass

img = cv2.imread('document.jpg', cv2.IMREAD_GRAYSCALE)

cv2.namedWindow('Threshold')

cv2.createTrackbar('Threshold', 'Threshold', 0, 255, nothing)
cv2.createTrackbar('Type', 'Threshold', 0, 4, nothing)

while True:
    thresh_val = cv2.getTrackbarPos('Threshold', 'Threshold')
    type_val = cv2.getTrackbarPos('Type', 'Threshold')

    types = [cv2.THRESH_BINARY, cv2.THRESH_BINARY_INV,
             cv2.THRESH_TRUNC, cv2.THRESH_TOZERO, cv2.THRESH_TOZERO_INV]

    ret, thresh = cv2.threshold(img, thresh_val, 255, types[type_val])

    cv2.imshow('Threshold', thresh)

    key = cv2.waitKey(1)
    if key == 27:  # ESC
        break

cv2.destroyAllWindows()
```

---

## 七、常见问题

### Q1：阈值处理后噪声太多？

**解决方案：**
```python
# 1. 预处理：先滤波
blur = cv2.GaussianBlur(img, (5, 5), 0)

# 2. 后处理：形态学操作
kernel = np.ones((3, 3), np.uint8)
opening = cv2.morphologyEx(thresh, cv2.MORPH_OPEN, kernel)

# 3. 调整参数
thresh = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY, 15, 5)
```

### Q2：如何判断图像是否适合Otsu？

**查看直方图：**
```python
import cv2
import matplotlib.pyplot as plt

img = cv2.imread('image.jpg', cv2.IMREAD_GRAYSCALE)

# 绘制直方图
hist = cv2.calcHist([img], [0], None, [256], [0, 256])
plt.plot(hist)
plt.show()

# 如果有两个明显的峰值，适合Otsu
```

### Q3：光照不均怎么办？

**使用自适应阈值：**
```python
# 对比三种方法
ret1, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY)
th2 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_MEAN_C,
                            cv2.THRESH_BINARY, 11, 2)
th3 = cv2.adaptiveThreshold(img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                            cv2.THRESH_BINARY, 11, 2)
```

---

## 八、练习题

### 练习1：基础阈值（⭐）
1. 读取一张灰度图
2. 分别使用127和Otsu阈值进行二值化
3. 对比效果

### 练习2：文档扫描（⭐⭐）
模拟文档扫描流程：
1. 读取文档图片
2. 转灰度 + 高斯滤波
3. 自适应阈值
4. 形态学去噪

### 练习3：参数调优（⭐⭐）
编写交互式程序，可以调整自适应阈值的blockSize和C参数。

### 练习4：条形码区域提取（⭐⭐⭐）
从包含条形码的图像中提取条形码区域（使用梯度+阈值）。

### 练习5：光照不均校正（⭐⭐⭐⭐）
实现一个程序，自动检测光照是否均匀，并选择合适的阈值方法。

---

## 九、扩展思考

1. **为什么blockSize必须是奇数？**
   - 提示：中心像素需要对称的邻域

2. **Otsu为什么只能用于双峰直方图？**
   - 提示：基于前景和背景的两类分割

3. **如何处理多峰直方图？**
   - 提示：多阈值分割、区域生长

---

**下一步：** 学习[07-形态学操作](./07-形态学操作.md)
