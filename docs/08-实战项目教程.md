# 实战项目教程

## 学习目标

- 综合运用OpenCV知识解决实际问题
- 掌握完整的计算机视觉项目流程
- 学会图像处理算法的组合应用
- 能够独立完成小型视觉项目

---

## 项目一：智能文档扫描器

### 项目描述

自动矫正文档图片的透视畸变，并增强对比度，使其适合扫描和打印。

### 技术要点

- 边缘检测（Canny）
- 轮廓查找
- 透视变换
- 自适应阈值

### 实现步骤

**步骤1：读取并预处理图像**

```python
import cv2
import numpy as np

img = cv2.imread('document.jpg')

# 转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 高斯滤波（降噪）
blur = cv2.GaussianBlur(gray, (5, 5), 0)

# Canny边缘检测
edges = cv2.Canny(blur, 50, 150)
```

**步骤2：查找文档轮廓**

```python
# 查找轮廓
contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL,
                               cv2.CHAIN_APPROX_SIMPLE)

# 按面积排序，找到最大的轮廓
contours = sorted(contours, key=cv2.contourArea, reverse=True)
doc_contour = contours[0]

# 多边形近似
epsilon = 0.02 * cv2.arcLength(doc_contour, True)
approx = cv2.approxPolyDP(doc_contour, epsilon, True)

# 确保有4个点
if len(approx) == 4:
    print("找到文档的4个角点")
    # 绘制轮廓
    cv2.drawContours(img, [approx], -1, (0, 255, 0), 3)
```

**步骤3：透视变换**

```python
# 获取4个角点坐标
points = approx.reshape(4, 2)

# 排序点：左上、右上、右下、左下
def order_points(pts):
    rect = np.zeros((4, 2), dtype='float32')

    # 按x坐标排序
    pts_sorted = pts[np.argsort(pts[:, 0])]

    # 左边的两个点
    left_points = pts_sorted[:2]
    right_points = pts_sorted[2:]

    # 左边按y排序
    left_points = left_points[np.argsort(left_points[:, 1])]
    # 右边按y排序
    right_points = right_points[np.argsort(right_points[:, 1])]

    rect[0] = left_points[0]  # 左上
    rect[3] = left_points[1]  # 左下
    rect[1] = right_points[0]  # 右上
    rect[2] = right_points[1]  # 右下

    return rect

rect = order_points(points)

# 计算新图像的尺寸
width_a = np.sqrt(((rect[2][0] - rect[3][0]) ** 2) +
                  ((rect[2][1] - rect[3][1]) ** 2))
width_b = np.sqrt(((rect[1][0] - rect[0][0]) ** 2) +
                  ((rect[1][1] - rect[0][1]) ** 2))
max_width = max(int(width_a), int(width_b))

height_a = np.sqrt(((rect[1][0] - rect[2][0]) ** 2) +
                   ((rect[1][1] - rect[2][1]) ** 2))
height_b = np.sqrt(((rect[0][0] - rect[3][0]) ** 2) +
                   ((rect[0][1] - rect[3][1]) ** 2))
max_height = max(int(height_a), int(height_b))

# 目标点
dst = np.array([
    [0, 0],
    [max_width - 1, 0],
    [max_width - 1, max_height - 1],
    [0, max_height - 1]
], dtype='float32')

# 计算透视变换矩阵
M = cv2.getPerspectiveTransform(rect, dst)

# 应用透视变换
warped = cv2.warpPerspective(img, M, (max_width, max_height))
```

**步骤4：后处理（增强）**

```python
# 转灰度
warped_gray = cv2.cvtColor(warped, cv2.COLOR_BGR2GRAY)

# 自适应阈值
thresh = cv2.adaptiveThreshold(warped_gray, 255,
                               cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY, 11, 2)

# 显示结果
cv2.imshow('Original', img)
cv2.imshow('Warped', warped)
cv2.imshow('Scanned', thresh)
cv2.waitKey(0)
cv2.destroyAllWindows()

# 保存结果
cv2.imwrite('scanned_document.jpg', thresh)
```

---

## 项目二：颜色识别与分类器

### 项目描述

识别图像中的不同颜色物体并计数，输出每种颜色的数量和位置。

### 技术要点

- HSV色彩空间
- 颜色阈值分割
- 轮廓检测
- 物体计数

### 实现步骤

**步骤1：定义颜色范围**

```python
import cv2
import numpy as np

# 定义颜色HSV范围
COLORS = {
    'red': {
        'lower': [0, 100, 100],
        'upper': [10, 255, 255],
        'label': 'Red'
    },
    'green': {
        'lower': [35, 100, 100],
        'upper': [85, 255, 255],
        'label': 'Green'
    },
    'blue': {
        'lower': [85, 100, 100],
        'upper': [135, 255, 255],
        'label': 'Blue'
    }
}
```

**步骤2：颜色检测函数**

```python
def detect_color(img, lower, upper):
    """检测指定颜色"""
    # 转HSV
    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)

    # 创建掩膜
    lower = np.array(lower)
    upper = np.array(upper)
    mask = cv2.inRange(hsv, lower, upper)

    # 形态学操作（去噪）
    kernel = np.ones((5, 5), np.uint8)
    mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)
    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)

    return mask
```

**步骤3：查找并统计物体**

```python
def count_objects(mask, min_area=500):
    """统计物体数量"""
    # 查找轮廓
    contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL,
                                   cv2.CHAIN_APPROX_SIMPLE)

    # 过滤小轮廓
    objects = []
    for contour in contours:
        area = cv2.contourArea(contour)
        if area > min_area:
            # 获取边界框
            x, y, w, h = cv2.boundingRect(contour)
            objects.append({
                'contour': contour,
                'bbox': (x, y, w, h),
                'area': area
            })

    return objects
```

**步骤4：主程序**

```python
# 读取图像
img = cv2.imread('colored-balls.jpg')

result_img = img.copy()

# 检测每种颜色
for color_name, color_info in COLORS.items():
    mask = detect_color(img, color_info['lower'], color_info['upper'])

    # 统计物体
    objects = count_objects(mask)

    # 绘制结果
    for obj in objects:
        x, y, w, h = obj['bbox']

        # 绘制边界框
        cv2.rectangle(result_img, (x, y), (x + w, y + h), (0, 255, 0), 2)

        # 添加标签
        label = f"{color_info['label']}"
        cv2.putText(result_img, label, (x, y - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.5, (0, 255, 0), 2)

    print(f"{color_name.capitalize()}: {len(objects)} 个")

# 显示结果
cv2.imshow('Original', img)
cv2.imshow('Detection Result', result_img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 项目三：简单人脸检测

### 项目描述

使用Haar级联分类器检测图像中的人脸，并绘制边界框。

### 技术要点

- Haar级联分类器
- 多尺度检测
- 非极大值抑制

### 实现步骤

**步骤1：加载级联分类器**

```python
import cv2

# 加载人脸检测器
face_cascade = cv2.CascadeClassifier(
    cv2.data.haarcascades + 'haarcascade_frontalface_default.xml'
)

# 加载人眼检测器（可选）
eye_cascade = cv2.CascadeClassifier(
    cv2.data.haarcascades + 'haarcascade_eye.xml'
)
```

**步骤2：检测人脸**

```python
# 读取图像
img = cv2.imread('face.jpg')

# 转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 检测人脸
faces = face_cascade.detectMultiScale(
    gray,
    scaleFactor=1.1,      # 缩放因子
    minNeighbors=5,       # 最小邻居数
    minSize=(30, 30)      # 最小人脸尺寸
)

print(f"检测到 {len(faces)} 个人脸")
```

**步骤3：绘制结果**

```python
result_img = img.copy()

for (x, y, w, h) in faces:
    # 绘制人脸矩形框
    cv2.rectangle(result_img, (x, y), (x + w, y + h), (255, 0, 0), 2)

    # 检测眼睛
    roi_gray = gray[y:y + h, x:x + w]
    roi_color = result_img[y:y + h, x:x + w]

    eyes = eye_cascade.detectMultiScale(roi_gray)

    for (ex, ey, ew, eh) in eyes:
        cv2.rectangle(roi_color, (ex, ey), (ex + ew, ey + eh),
                      (0, 255, 0), 2)

# 显示结果
cv2.imshow('Face Detection', result_img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

**步骤4：实时摄像头检测**

```python
# 打开摄像头
cap = cv2.VideoCapture(0)

while True:
    ret, frame = cap.read()

    if not ret:
        break

    # 转灰度
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # 检测人脸
    faces = face_cascade.detectMultiScale(gray, 1.1, 5)

    # 绘制结果
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 0, 0), 2)

    cv2.imshow('Face Detection', frame)

    # 按ESC退出
    if cv2.waitKey(1) == 27:
        break

cap.release()
cv2.destroyAllWindows()
```

---

## 项目四：车牌区域定位

### 项目描述

从车辆图片中定位车牌区域。

### 技术要点

- 灰度转换
- Sobel边缘检测
- 形态学操作
- 轮廓筛选

### 实现步骤

```python
import cv2
import numpy as np

img = cv2.imread('car.jpg')

# 1. 转灰度
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# 2. 高斯滤波
blur = cv2.GaussianBlur(gray, (5, 5), 0)

# 3. Sobel边缘检测（垂直边缘）
sobelx = cv2.Sobel(blur, cv2.CV_64F, 1, 0, ksize=3)
abs_sobelx = np.absolute(sobelx)
sobelx = np.uint8(abs_sobelx)

# 4. Otsu阈值
ret, thresh = cv2.threshold(sobelx, 0, 255,
                           cv2.THRESH_BINARY + cv2.THRESH_OTSU)

# 5. 形态学操作（连接字符）
kernel = np.ones((3, 3), np.uint8)
closed = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

# 6. 膨胀（水平方向）
kernel_horiz = np.ones((1, 10), np.uint8)
dilated = cv2.dilate(closed, kernel_horiz, iterations=1)

# 7. 查找轮廓
contours, _ = cv2.findContours(dilated, cv2.RETR_EXTERNAL,
                               cv2.CHAIN_APPROX_SIMPLE)

result_img = img.copy()

# 8. 筛选轮廓
for contour in contours:
    x, y, w, h = cv2.boundingRect(contour)

    # 车牌比例筛选（宽高比通常在2-5之间）
    aspect_ratio = w / float(h)

    if 2 < aspect_ratio < 5 and w > 50 and h > 10:
        cv2.rectangle(result_img, (x, y), (x + w, y + h),
                      (0, 255, 0), 2)

cv2.imshow('Original', img)
cv2.imshow('License Plate Detection', result_img)
cv2.waitKey(0)
cv2.destroyAllWindows()
```

---

## 项目开发流程总结

### 标准流程

1. **需求分析**
   - 明确目标
   - 确定输入输出

2. **图像预处理**
   - 灰度转换
   - 降噪滤波
   - 尺寸调整

3. **核心算法**
   - 边缘检测 / 阈值分割
   - 特征提取
   - 目标检测

4. **后处理**
   - 形态学操作
   - 轮廓筛选
   - 结果优化

5. **可视化**
   - 绘制结果
   - 输出数据

6. **测试与优化**
   - 多场景测试
   - 参数调优
   - 性能优化

---

## 调试技巧

### 1. 中间结果可视化

```python
cv2.imshow('Step 1: Gray', gray)
cv2.imshow('Step 2: Blur', blur)
cv2.imshow('Step 3: Edges', edges)
cv2.waitKey(0)
```

### 2. 参数调试

```python
# 使用滑动条调整参数
cv2.createTrackbar('Threshold', 'Window', 0, 255, nothing)
```

### 3. 多图像测试

```python
# 测试不同场景
test_images = ['test1.jpg', 'test2.jpg', 'test3.jpg']

for img_path in test_images:
    img = cv2.imread(img_path)
    # 处理逻辑...
```

---

## 练习题

### 练习1：文档扫描器（⭐⭐⭐）
实现完整的文档扫描器，包括透视矫正和二值化。

### 练习2：颜色追踪（⭐⭐⭐）
从摄像头实时追踪特定颜色的物体。

### 练习3：二维码识别（⭐⭐⭐⭐）
使用OpenCV的QRCode检测器识别二维码。

### 练习4：运动检测（⭐⭐⭐⭐）
检测视频中的运动物体（帧差法）。

---

## 扩展学习

- **深度学习目标检测**：YOLO、SSD
- **特征匹配**：SIFT、ORB
- **视频分析**：光流法、背景减除
- **3D视觉**：立体视觉、点云

---

**下一步：** 查看[09-常见问题与调试技巧](./09-常见问题与调试技巧.md)
