# 常见问题与调试技巧

## 学习目标

- 掌握OpenCV开发中的常见问题及解决方案
- 学会高效的调试方法
- 了解性能优化技巧
- 提高代码质量

---

## 一、环境问题

### Q1：ImportError: No module named 'cv2'

**问题：**
```python
import cv2
# ImportError: No module named 'cv2'
```

**解决方案：**
```bash
# 确认OpenCV已安装
pip list | grep opencv

# 重新安装
pip uninstall opencv-python
pip install opencv-python

# 或使用国内镜像
pip install opencv-python -i https://pypi.tuna.tsinghua.edu.cn/simple
```

### Q2：cv2.imshow()窗口无响应

**问题：** 窗口显示但无法关闭，程序卡死

**解决方案：**
```python
# ❌ 错误
cv2.imshow('image', img)
# 缺少 cv2.waitKey()

# ✅ 正确
cv2.imshow('image', img)
cv2.waitKey(0)  # 必须加这行
cv2.destroyAllWindows()
```

### Q3：中文路径问题

**问题：**
```python
img = cv2.imread('图片/测试.jpg')
# 无法读取，返回None
```

**解决方案：**
```python
# 方法1：使用numpy读取
import numpy as np
from PIL import Image

img = np.array(Image.open('图片/测试.jpg'))
img = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)

# 方法2：避免中文路径
img = cv2.imread('images/test.jpg')
```

---

## 二、图像读取与显示问题

### Q4：图像读取失败（返回None）

**问题：**
```python
img = cv2.imread('photo.jpg')
print(img)  # None
```

**解决方案：**
```python
# 1. 检查文件是否存在
import os
if not os.path.exists('photo.jpg'):
    print("文件不存在！")

# 2. 检查路径是否正确
print(os.path.abspath('photo.jpg'))

# 3. 使用绝对路径
img = cv2.imread(r'D:\images\photo.jpg')

# 4. 添加错误处理
img = cv2.imread('photo.jpg')
if img is None:
    print("无法读取图片！")
    exit()
```

### Q5：颜色显示异常

**问题：** OpenCV读取的图像颜色不对

**原因：** OpenCV使用BGR，matplotlib使用RGB

**解决方案：**
```python
import cv2
import matplotlib.pyplot as plt

img = cv2.imread('photo.jpg')

# ❌ 错误：直接用matplotlib显示
plt.imshow(img)  # 颜色会变

# ✅ 正确：先转换
img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
plt.imshow(img_rgb)
plt.show()
```

### Q6：imshow显示全白或全黑

**问题：** 图像显示异常，全白或全黑

**可能原因：**
1. 数据类型错误
2. 像素值超出范围
3. 图像全0或全255

**解决方案：**
```python
# 检查图像属性
print(f"数据类型: {img.dtype}")
print(f"值范围: {img.min()} - {img.max()}")
print(f"形状: {img.shape}")

# 归一化到0-255
img_normalized = cv2.normalize(img, None, 0, 255, cv2.NORM_MINMAX)

# 转换为uint8
img_uint8 = np.uint8(img_normalized)
```

---

## 三、操作错误

### Q7：索引顺序错误

**问题：**
```python
pixel = img[x, y]  # 顺序错误
```

**解决方案：**
```python
# ✅ 正确：先y后x
pixel = img[y, x]

# ✅ 或使用命名
row, col = 100, 200
pixel = img[row, col]
```

### Q8：尺寸不匹配

**问题：**
```python
result = cv2.add(img1, img2)
# cv2.error: sizes of input arguments do not match
```

**解决方案：**
```python
# 检查尺寸
print(f"Image 1: {img1.shape}")
print(f"Image 2: {img2.shape}")

# 调整尺寸
img2_resized = cv2.resize(img2, (img1.shape[1], img1.shape[0]))

# 再相加
result = cv2.add(img1, img2_resized)
```

### Q9：通道数错误

**问题：**
```python
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
# 然后对gray进行BGR转换会报错
```

**解决方案：**
```python
# 检查通道数
if len(img.shape) == 2:
    print("灰度图")
elif len(img.shape) == 3:
    print(f"彩色图，{img.shape[2]}个通道")

# 只对彩色图进行颜色转换
if len(img.shape) == 3:
    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
```

---

## 四、算法效果问题

### Q10：边缘检测效果差

**问题：** Canny边缘检测效果不理想

**解决方案：**
```python
# 1. 预处理：降噪
blur = cv2.GaussianBlur(gray, (5, 5), 0)

# 2. 调整阈值
edges = cv2.Canny(blur, 50, 150)

# 3. 自动计算阈值
median = np.median(blur)
lower = int(max(0, 0.7 * median))
upper = int(min(255, 1.3 * median))
edges = cv2.Canny(blur, lower, upper)

# 4. 后处理：连接断开的边缘
kernel = np.ones((3, 3), np.uint8)
edges = cv2.dilate(edges, kernel, iterations=1)
```

### Q11：颜色提取不准确

**问题：** HSV颜色提取效果差

**解决方案：**
```python
# 1. 调整HSV范围（扩大范围）
lower = np.array([h - 15, s - 50, v - 50])
upper = np.array([h + 15, s + 50, v + 50])

# 2. 形态学去噪
mask = cv2.inRange(hsv, lower, upper)
kernel = np.ones((5, 5), np.uint8)
mask = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

# 3. 多个范围合并（针对红色等）
mask1 = cv2.inRange(hsv, lower1, upper1)
mask2 = cv2.inRange(hsv, lower2, upper2)
mask = cv2.bitwise_or(mask1, mask2)
```

### Q12：轮廓检测不理想

**问题：** findContours检测不到或检测太多

**解决方案：**
```python
# 1. 预处理优化
blur = cv2.GaussianBlur(gray, (5, 5), 0)
thresh = cv2.adaptiveThreshold(blur, 255,
                               cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                               cv2.THRESH_BINARY, 11, 2)

# 2. 形态学操作
kernel = np.ones((3, 3), np.uint8)
thresh = cv2.morphologyEx(thresh, cv2.MORPH_CLOSE, kernel)

# 3. 查找轮廓
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL,
                               cv2.CHAIN_APPROX_SIMPLE)

# 4. 过滤小轮廓
min_area = 500
filtered_contours = [c for c in contours if cv2.contourArea(c) > min_area]
```

---

## 五、调试技巧

### 技巧1：逐步可视化

```python
# 每一步都可视化结果
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
cv2.imshow('1-Gray', gray)

blur = cv2.GaussianBlur(gray, (5, 5), 0)
cv2.imshow('2-Blur', blur)

edges = cv2.Canny(blur, 50, 150)
cv2.imshow('3-Edges', edges)

cv2.waitKey(0)
cv2.destroyAllWindows()
```

### 技巧2：打印关键信息

```python
print(f"图像尺寸: {img.shape}")
print(f"数据类型: {img.dtype}")
print(f"值范围: {img.min()} - {img.max()}")
print(f"轮廓数量: {len(contours)}")
print(f"最大轮廓面积: {max([cv2.contourArea(c) for c in contours])}")
```

### 技巧3：使用matplotlib对比

```python
import matplotlib.pyplot as plt

fig, axes = plt.subplots(2, 3, figsize=(15, 10))

axes[0, 0].imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
axes[0, 0].set_title('Original')

axes[0, 1].imshow(gray, cmap='gray')
axes[0, 1].set_title('Gray')

axes[0, 2].imshow(edges, cmap='gray')
axes[0, 2].set_title('Edges')

plt.tight_layout()
plt.show()
```

### 技巧4：交互式调试

```python
# 使用滑动条调整参数
cv2.namedWindow('Threshold')

cv2.createTrackbar('Threshold1', 'Threshold', 50, 255, nothing)
cv2.createTrackbar('Threshold2', 'Threshold', 150, 255, nothing)

while True:
    t1 = cv2.getTrackbarPos('Threshold1', 'Threshold')
    t2 = cv2.getTrackbarPos('Threshold2', 'Threshold')

    edges = cv2.Canny(blur, t1, t2)
    cv2.imshow('Threshold', edges)

    if cv2.waitKey(1) == 27:
        break

cv2.destroyAllWindows()
```

---

## 六、性能优化

### 优化1：减少循环

```python
# ❌ 慢：使用循环
for i in range(height):
    for j in range(width):
        gray[i, j] = (img[i, j, 0] + img[i, j, 1] + img[i, j, 2]) // 3

# ✅ 快：使用内置函数
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
```

### 优化2：图像缩放

```python
# 处理大图像时先缩小
small_img = cv2.resize(img, (0, 0), fx=0.5, fy=0.5)

# 处理完成后再放大回原尺寸
result = cv2.resize(result, (img.shape[1], img.shape[0]))
```

### 优化3：提前释放内存

```python
# 及时关闭窗口
cv2.destroyAllWindows()

# 释放视频资源
cap.release()

# 删除大变量
del large_image
```

---

## 七、常见错误代码

### 错误1：数组越界

```python
# ❌ 错误
h, w = img.shape
pixel = img[h, w]  # 越界

# ✅ 正确
pixel = img[h-1, w-1]
```

### 错误2：类型错误

```python
# ❌ 错误
img_float = img.astype(np.float32)
result = cv2.cvtColor(img_float, cv2.COLOR_BGR2GRAY)  # 报错

# ✅ 正确
img_uint8 = img.astype(np.uint8)
result = cv2.cvtColor(img_uint8, cv2.COLOR_BGR2GRAY)
```

### 错误3：拷贝 vs 引用

```python
# ❌ 错误：修改crop会影响原图
crop = img[100:200, 100:200]
crop[:, :] = [255, 255, 255]  # 也会修改img

# ✅ 正确：使用copy()
crop = img[100:200, 100:200].copy()
crop[:, :] = [255, 255, 255]  # 不会影响img
```

---

## 八、最佳实践

### 1. 代码模板

```python
import cv2
import numpy as np

def process_image(img_path):
    # 1. 读取图像
    img = cv2.imread(img_path)
    if img is None:
        print(f"无法读取 {img_path}")
        return None

    # 2. 预处理
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blur = cv2.GaussianBlur(gray, (5, 5), 0)

    # 3. 核心处理
    edges = cv2.Canny(blur, 50, 150)

    # 4. 后处理
    kernel = np.ones((3, 3), np.uint8)
    edges = cv2.morphologyEx(edges, cv2.MORPH_CLOSE, kernel)

    return edges

# 使用
result = process_image('photo.jpg')
if result is not None:
    cv2.imshow('Result', result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()
```

### 2. 错误处理

```python
def safe_read_image(img_path):
    """安全读取图像"""
    img = cv2.imread(img_path)

    if img is None:
        raise FileNotFoundError(f"无法读取图像: {img_path}")

    if len(img.shape) != 3:
        raise ValueError("图像必须是彩色图")

    return img

def safe_process(img):
    """安全处理图像"""
    if img is None:
        raise ValueError("图像不能为None")

    if img.size == 0:
        raise ValueError("图像不能为空")

    # 处理逻辑...
    return result
```

### 3. 日志记录

```python
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

logger.info(f"开始处理图像: {img_path}")
logger.info(f"图像尺寸: {img.shape}")
logger.info(f"检测到 {len(contours)} 个轮廓")
```

---

## 九、练习题

### 练习1：调试代码（⭐）
找出并修复以下代码的错误：
```python
img = cv2.imread('photo.jpg')
pixel = img[500, 500]
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
gray = cv2.cvtColor(gray, cv2.COLOR_BGR2RGB)
```

### 练习2：优化代码（⭐⭐）
优化以下代码的性能：
```python
for i in range(img.shape[0]):
    for j in range(img.shape[1]):
        if img[i, j] > 127:
            img[i, j] = 255
        else:
            img[i, j] = 0
```

### 练习3：错误处理（⭐⭐）
为一个完整的图像处理流程添加错误处理和日志记录。

---

## 十、扩展资源

### 文档
- [OpenCV官方文档](https://docs.opencv.org/4.x/)
- [OpenCV Python教程](https://docs.opencv.org/4.x/d6/d00/tutorial_py_root.html)

### 社区
- Stack Overflow: [opencv标签](https://stackoverflow.com/questions/tagged/opencv)
- GitHub: [opencv仓库](https://github.com/opencv/opencv)

### 工具
- 在线Canny测试: [Canny Edge Detector Playground](https://demo.imgly.com/)

---

**完成！** 现在你已经掌握了OpenCV的基础知识和常见问题解决方案。继续练习和探索，你会发现更多有趣的计算机视觉应用！
